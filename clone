    };
    // var u = Graph.prototype.splitEdge;
    // Graph.prototype.splitEdge = function(p, A, B, F, K, R, Z, ha) {
    //     null == ha && (ha = this.model.getParent(p),
    //         this.isTable(ha) || this.isTableRow(ha)) && (ha = this.getCellAt(R, Z, null, !0, !1));
    //     B = null;
    //     this.model.beginUpdate();
    //     try {
    //         B = u.apply(this, [p, A, B, F, K, R, Z, ha]);
    //         this.model.setValue(B, "");
    //         var fa = this.getChildCells(B, !0);
    //         for (A = 0; A < fa.length; A++) {
    //             var ia = this.getCellGeometry(fa[A]);
    //             null != ia && ia.relative && 0 < ia.x && this.model.remove(fa[A])
    //         }
    //         var va = this.getChildCells(p, !0);
    //         for (A = 0; A < va.length; A++) ia = this.getCellGeometry(va[A]), null != ia && ia.relative && 0 >= ia.x && this.model.remove(va[A]);
    //         var Ma = this.model.getTerminal(B, !1);
    //         if (null != Ma) {
    //             var Na = this.getCurrentCellStyle(Ma);
    //             null != Na && "1" == Na.snapToPoint && (this.setCellStyles(mxConstants.STYLE_EXIT_X, null, [p]), this.setCellStyles(mxConstants.STYLE_EXIT_Y, null, [p]), this.setCellStyles(mxConstants.STYLE_ENTRY_X, null, [B]), this.setCellStyles(mxConstants.STYLE_ENTRY_Y, null, [B]))
    //         }
    //     } finally {
    //         this.model.endUpdate()
    //     }
    //     return B
    // };
mxGraph.prototype.splitEdge = function(a, b, c, d, e, f, g, k) {
    d = d || 0;
    e = e || 0;
    k = k != null ? k : this.model.getParent(a);
    f = this.model.getTerminal(a, true);

    this.model.beginUpdate();
    try {
        // 새 edge c가 없으면 복제해서 생성
        if (c == null) {
            c = this.cloneCell(a);
            var state = this.view.getState(a);
            var geo = this.getCellGeometry(c);

            if (geo != null && geo.points != null && state != null) {
                var translate = this.view.translate;
                var scale = this.view.scale;
                var segmentIndex = mxUtils.findNearestSegment(state, (d + translate.x) * scale, (e + translate.y) * scale);

                // 원래 edge와 clone edge의 points 분할
                geo.points = geo.points.slice(0, segmentIndex);
                var originalGeo = this.getCellGeometry(a);
                if (originalGeo != null && originalGeo.points != null) {
                    originalGeo = originalGeo.clone();
                    originalGeo.points = originalGeo.points.slice(segmentIndex);
                    this.model.setGeometry(a, originalGeo);
                }
            }
        }

        // 노드 이동
        this.cellsMoved(b, d, e, false, false);

        // c를 먼저 추가
        this.cellsAdded([c], k, this.model.getChildCount(k), f, b[0], false);

        // b 노드 추가
        this.cellsAdded(b, k, this.model.getChildCount(k), null, null, true);

        // 연결
        this.cellConnected(a, b[0], true);

        // 🔄 Z-순서 직접 조정: c를 a 바로 뒤에 삽입
        const model = this.model;
        const parent = k;
        const children = model.getChildCells(parent);
        const aIndex = children.indexOf(a);

        model.remove(c);
        model.add(parent, c, aIndex); // a 바로 뒤에 삽입


        // 이벤트 발생
        this.fireEvent(new mxEventObject(mxEvent.SPLIT_EDGE, "edge", a, "cells", b, "newEdge", c, "dx", d, "dy", e));
    } finally {
        this.model.endUpdate();
    }

    return c;
};
